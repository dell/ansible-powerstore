#!/usr/bin/python
# Copyright: (c) 2024, Dell Technologies
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

from __future__ import absolute_import, division, print_function

__metaclass__ = type

DOCUMENTATION = r'''
---
module: host
version_added: '1.0.0'
short_description: Manage host on PowerStore storage system
description:
- Managing host on PowerStore storage system includes create host with a
  set of initiators, add/remove initiators from host, rename host and
  delete host.
author:
- Manisha Agrawal (@agrawm3) <ansible.team@dell.com>
extends_documentation_fragment:
  - dellemc.powerstore.powerstore
options:
  description:
    description:
    - An optional description for the host.
    - The description should not be more than 256 UTF-8
      characters long and should not have any unprintable characters.
    type: str
  detailed_initiators:
      description:
      - Initiator properties.
      - It is mutually exclusive with I(initiators).
      type: list
      elements: dict
      suboptions:
        chap_mutual_password:
          description:
          - Password for mutual CHAP authentication.
          - CHAP password is required when the cluster CHAP mode is mutual
            authentication.
          - Minimum length is 12 and maximum length is 64 characters.
          - 'The CHAP password must be 12 to 64 characters and can only contain English letters, numbers, and some special
            characters (such as + : ; , / # _ @ * % $ ! ( ) [ ]).'
          type: str
        chap_mutual_username:
          description:
          - Username for mutual CHAP authentication.
          - CHAP username is required when the cluster CHAP mode is mutual
            authentication.
          - Minimum length is 1 and maximum length is 64 characters.
          type: str
        chap_single_password:
          description:
          - Password for single CHAP authentication.
          - CHAP password is required when the cluster CHAP mode is mutual
            authentication.
          - Minimum length is 12 and maximum length is 64 characters.
          - 'The CHAP password must be 12 to 64 characters and can only contain English letters, numbers, and some special
            characters (such as + : ; , / # _ @ * % $ ! ( ) [ ]).'
          type: str
        chap_single_username:
          description:
          - Username for single CHAP authentication.
          - CHAP username is required when the cluster CHAP mode is mutual
            authentication.
          - Minimum length is 1 and maximum length is 64 characters.
          type: str
        port_name:
          description:
          - Name of port type.
          - The I(port_name) is mandatory key.
          type: str
          required: true
        port_type:
          description:
          - Protocol type of the host initiator.
          type: str
          choices: ['iSCSI', 'FC', 'NVMe']
  host_connectivity:
    description:
    - Connectivity type for host.
    - If any of metro connectivity options specified, a metro host must
      exists in both cluster provide connectivity to a metro volume from both
      cluster.
    choices: ['Local_Only', 'Metro_Optimize_Both', 'Metro_Optimize_Local',
              'Metro_Optimize_Remote']
    type: str
  host_id:
    description:
    - The 36 character long host id automatically generated when a host is
      created.
    - Use either I(host_id) or I(host_name) for modify and delete tasks.
    - The I(host_id) cannot be used while creating host, as it is generated by
      the array after creation of host.
    type: str
  host_name:
    description:
    - The host name. This value must contain 128 or fewer printable Unicode
      characters.
    - Creation of an empty host is not allowed.
    - Required when creating a host.
    - Use either I(host_id) or I(host_name) for modify and delete tasks.
    type: str
  initiators:
      description:
      - List of Initiator WWN or IQN or NQN to be added or removed from the
        host.
      - Subordinate initiators in a host can only be of one type, either FC or
        iSCSI.
      - Required when creating a host.
      - It is mutually exclusive with I(detailed_initiators).
      type: list
      elements: str
  initiator_state:
    description:
    - Define whether the initiators should be present or absent in host.
    - Value C(present-in-host) - indicates that the initiators should exist on
      host.
    - Value C(absent-in-host) - indicates that the initiators should not exist on
      host.
    - Required when creating a host with initiators or adding/removing
      initiators to/from existing host.
    choices: ['present-in-host', 'absent-in-host']
    type: str
  new_name:
    description:
    - The new name of host for renaming function. This value must contain 128
      or fewer printable Unicode characters.
    - Cannot be specified when creating a host.
    type: str
  os_type:
      description:
      - Operating system of the host.
      - Required when creating a host.
      - OS type cannot be modified for a given host.
      choices: ['Windows', 'Linux', 'ESXi', 'AIX', 'HP-UX', 'Solaris']
      type: str
  state:
    description:
    - Define whether the host should exist or not.
    - Value C(present) - indicates that the host should exist in system.
    - Value C(absent) - indicates that the host should not exist in system.
    choices: ['absent', 'present']
    default: 'present'
    type: str
attributes:
  check_mode:
    description: Runs task to validate without performing action on the target
                 machine.
    support: full
  diff_mode:
    description: Runs the task to report the changes made or to be made.
    support: full
notes:
- Only completely and correctly configured iSCSI initiators can be associated
  with a host.
- The parameters I(initiators) and I(detailed_initiators) are mutually exclusive.
- For mutual CHAP authentication, single CHAP credentials are mandatory.
- Support of C(NVMe) type of initiators is for PowerStore 2.0 and beyond.
- The I(host_connectivity) is supported only in PowerStore 3.0.0.0 and above.
'''
EXAMPLES = r'''
- name: Create host with FC initiator
  dellemc.powerstore.host:
    array_ip: "{{array_ip}}"
    validate_certs: "{{validate_certs}}"
    user: "{{user}}"
    password: "{{password}}"
    host_name: "ansible-test-host-1"
    os_type: 'Windows'
    host_connectivity: "Metro_Optimize_Local"
    initiators:
      - 21:00:00:24:ff:31:e9:fc
    state: 'present'
    initiator_state: 'present-in-host'

- name: Create host with iSCSI initiator and its details
  dellemc.powerstore.host:
    array_ip: "{{array_ip}}"
    validate_certs: "{{validate_certs}}"
    user: "{{user}}"
    password: "{{password}}"
    host_name: "ansible-test-host-2"
    os_type: 'Windows'
    detailed_initiators:
      - port_name: 'iqn.1998-01.com.vmware:lgc198248-5b06fb37'
        port_type: 'iSCSI'
        chap_single_username: 'chapuserSingle'
        chap_single_password: 'chappasswd12345'
      - port_name: 'iqn.1998-01.com.vmware:imn198248-5b06fb37'
        port_type: 'iSCSI'
        chap_mutual_username: 'chapuserMutual'
        chap_mutual_password: 'chappasswd12345'
    state: 'present'
    initiator_state: 'present-in-host'

- name: Get host details by id
  dellemc.powerstore.host:
    array_ip: "{{array_ip}}"
    validate_certs: "{{validate_certs}}"
    user: "{{user}}"
    password: "{{password}}"
    host_id: "5c1e869b-ed8a-4845-abae-b102bc249d41"
    state: 'present'

- name: Add initiators to host by name
  dellemc.powerstore.host:
    array_ip: "{{array_ip}}"
    validate_certs: "{{validate_certs}}"
    user: "{{user}}"
    password: "{{password}}"
    host_name: "ansible-test-host-1"
    initiators:
      - 21:00:00:24:ff:31:e9:ee
    initiator_state: 'present-in-host'
    state: 'present'

- name: Add initiators to host by id
  dellemc.powerstore.host:
    array_ip: "{{array_ip}}"
    validate_certs: "{{validate_certs}}"
    user: "{{user}}"
    password: "{{password}}"
    host_id: "5c1e869b-ed8a-4845-abae-b102bc249d41"
    detailed_initiators:
      - port_name: 'iqn.1998-01.com.vmware:imn198248-5b06fb37'
        port_type: 'iSCSI'
        chap_mutual_username: 'chapuserMutual'
        chap_mutual_password: 'chappasswd12345'
    initiator_state: 'present-in-host'
    state: 'present'

- name: Remove initiators from by id
  dellemc.powerstore.host:
    array_ip: "{{array_ip}}"
    validate_certs: "{{validate_certs}}"
    user: "{{user}}"
    password: "{{password}}"
    host_id: "8c1e869b-fe8a-4845-hiae-h802bc249d41"
    initiators:
      - 21:00:00:24:ff:31:e9:ee
    initiator_state: 'absent-in-host'
    state: 'present'

- name: Modify host by name
  dellemc.powerstore.host:
    array_ip: "{{array_ip}}"
    validate_certs: "{{validate_certs}}"
    user: "{{user}}"
    password: "{{password}}"
    host_name: "ansible-test-host-1"
    new_name: "ansible-test-host-1-new"
    host_connectivity: "Metro_Optimize_Remote"
    state: 'present'

- name: Delete host
  dellemc.powerstore.host:
    array_ip: "{{array_ip}}"
    validate_certs: "{{validate_certs}}"
    user: "{{user}}"
    password: "{{password}}"
    host_name: "ansible-test-host-1-new"
    state: 'absent'
'''

RETURN = r'''

changed:
    description: Whether or not the resource has changed.
    returned: always
    type: bool
    sample: "false"

host_details:
    description: Details of the host.
    returned: When host exists
    type: complex
    contains:
        id:
            description: The system generated ID given to the host.
            type: str
        name:
            description: Name of the host.
            type: str
        description:
            description: Description about the host.
            type: str
        host_group_id:
            description: The host group ID of host.
            type: str
        os_type:
            description: The os type of the host.
            type: str
        host_initiators:
            description: The initiator details of this host.
            type: complex
            contains:
                port_name:
                    description: Name of the port.
                    type: str
                port_type:
                    description: The type of the port.
                    type: str
                chap_single_username:
                    description: Username for single CHAP authentication.
                    type: str
                chap_mutual_username:
                    description: Username for mutual CHAP authentication.
                    type: str
                active_sessions:
                    description: List of active login sessions between an
                                 initiator and a target port.
                    type: list
        type:
            description: Type of the host.
            type: str
        mapped_hosts:
            description: This is the inverse of the resource type
                         I(host_volume_mapping) association.
            type: complex
            contains:
                id:
                    description: Unique identifier of a mapping between
                                 a host and a volume.
                    type: str
                logical_unit_number:
                    description: Logical unit number for the host volume
                                 access.
                    type: int
                host_group:
                    description: Details about a host group to which host is
                                 mapped.
                    type: dict
                    contains:
                        id:
                            description: ID of the host group.
                            type: str
                        name:
                            description: Name of the host group.
                            type: str
                volume:
                    description: Details about a volume which has mapping with
                                 the host.
                    type: dict
                    contains:
                        id:
                            description: ID of the volume.
                            type: str
                        name:
                            description: Name of the volume.
                            type: str
        host_connectivity:
            description: Connectivity type for host. It was added in 3.0.0.0.
            type: str
    sample: {
        "description": null,
        "host_group_id": null,
        "host_initiators": [
            {
                "active_sessions": [],
                "chap_mutual_username": "",
                "chap_single_username": "",
                "port_name": "iqn.1998-01.com.vmware:losat106-0eab2afe",
                "port_type": "iSCSI"
            }
        ],
        "id": "4d56e60-fc10-4f51-a698-84a664562f0d",
        "mapped_hosts": [],
        "name": "sample_host",
        "os_type": "ESXi",
        "host_connectivity": "Local_Only",
        "os_type_l10n": "ESXi"
    }
'''

from ansible.module_utils.basic import AnsibleModule
from ansible_collections.dellemc.powerstore.plugins.module_utils.storage.dell \
    import utils
import logging
import copy
import re

LOG = utils.get_logger('host', log_devel=logging.INFO)

py4ps_sdk = utils.has_pyu4ps_sdk()
HAS_PY4PS = py4ps_sdk['HAS_Py4PS']
IMPORT_ERROR = py4ps_sdk['Error_message']

py4ps_version = utils.py4ps_version_check()
IS_SUPPORTED_PY4PS_VERSION = py4ps_version['supported_version']
VERSION_ERROR = py4ps_version['unsupported_version_message']

# DO NOT CHANGE BELOW PORT_TYPES SEQUENCE AS ITS USED IN SCRIPT USING INDEX
PORT_TYPES = ["iSCSI", "FC", "NVMe"]


class PowerStoreHost(object):
    '''Class with host(initiator group) operations'''

    def __init__(self):
        # Define all parameters required by this module
        self.module_params = utils.get_powerstore_management_host_parameters()
        self.module_params.update(get_powerstore_host_parameters())
        mutually_exclusive = [['host_name', 'host_id'],
                              ['initiators', 'detailed_initiators']]
        required_one_of = [['host_name', 'host_id']]
        # Initialize the Ansible module
        self.module = AnsibleModule(
            argument_spec=self.module_params,
            supports_check_mode=True,
            mutually_exclusive=mutually_exclusive,
            required_one_of=required_one_of
        )

        LOG.info(
            'HAS_PY4PS = %s , IMPORT_ERROR = %s', HAS_PY4PS, IMPORT_ERROR)
        if HAS_PY4PS is False:
            self.module.fail_json(msg=IMPORT_ERROR)
        LOG.info(
            'IS_SUPPORTED_PY4PS_VERSION = %s , VERSION_ERROR = %s',
            IS_SUPPORTED_PY4PS_VERSION, VERSION_ERROR)
        if IS_SUPPORTED_PY4PS_VERSION is False:
            self.module.fail_json(msg=VERSION_ERROR)

        # result is a dictionary that contains changed status and host details
        self.result = {
            "changed": False,
            "host_details": {},
            "diff": {}
        }

        self.conn = utils.get_powerstore_connection(self.module.params)
        LOG.info(
            'Got Python library connection instance for provisioning on'
            ' PowerStore %s', self.conn)

    def get_host(self, host_id):
        '''
        Get details of a given host, given host ID
        '''
        try:
            LOG.info('Getting host %s details', host_id)
            host_from_get = self.conn.provisioning.get_host_details(host_id)
            if host_from_get:
                return host_from_get
            return None
        except Exception as e:
            error_msg = 'Unable to get details of host with ID: {0}' \
                        ' -- error: {1}'.format(host_id, str(e))
            LOG.error(error_msg)
            self.module.fail_json(msg=error_msg, **utils.failure_codes(e))

    def get_host_id_by_name(self, host_name):
        try:
            host_info = self.conn.provisioning.get_host_by_name(host_name)
            if host_info:
                if len(host_info) > 1:
                    error_msg = 'Multiple hosts by the same name found'
                    LOG.error(error_msg)
                    self.module.fail_json(msg=error_msg)
                return host_info[0]['id']
        except Exception as e:
            msg = 'Get Host {0} Details for powerstore array failed with ' \
                  'error: {1}'.format(host_name, str(e))
            if isinstance(e, utils.PowerStoreException) and \
                    e.err_code == utils.PowerStoreException.HTTP_ERR \
                    and e.status_code == "404":
                LOG.info(msg)
                return None
            LOG.error(msg)
            self.module.fail_json(msg=msg, **utils.failure_codes(e))

    def create_host(self, host_name):
        """
        Create host with given initiators
        """
        try:
            params = self.module.params
            initiators = params.get('initiators')
            detailed_initiators = params.get('detailed_initiators')
            host_connectivity = params.get('host_connectivity')
            os_type = params.get('os_type')

            if os_type is None:
                error_msg = "Create host {0} failed as os_type is not " \
                            "specified".format(host_name)
                LOG.error(error_msg)
                self.module.fail_json(msg=error_msg)

            if initiators:
                list_of_initiators = [
                    {
                        'port_name': i,
                        'port_type': self._get_port_type(i)
                    } for i in initiators
                ]
            else:
                list_of_initiators = detailed_initiators

            if list_of_initiators:
                port_types = set(i['port_type'] for i in list_of_initiators)
                if len(port_types) > 1:
                    inits = [i['port_name'] for i in list_of_initiators]
                    error_msg = ('Invalid initiators. Cannot add IQN, WWN and'
                                 ' NQN as part of host. Connect either fiber '
                                 'channel or iSCSI or NVMe. Initiators: {0}'.format(inits))
                    LOG.error(error_msg)
                    self.module.fail_json(msg=error_msg)

            payload = {
                'name': host_name,
                'os_type': os_type,
                'initiators': list_of_initiators,
                'host_connectivity': host_connectivity,
                'description': params.get('description')
            }

            if not self.module.check_mode:
                LOG.info("Creating host %s with initiators %s", host_name,
                         list_of_initiators)
                self.conn.provisioning.create_host(**payload)
            return True

        except Exception as e:
            error_msg = 'Create host {0} failed with error {1}'.format(
                host_name, str(e))
            LOG.error(error_msg)
            self.module.fail_json(msg=error_msg, **utils.failure_codes(e))

    def _get_port_type(self, initiator):
        if initiator.startswith('iqn'):
            return PORT_TYPES[0]
        elif initiator.startswith('nqn'):
            return PORT_TYPES[2]
        else:
            return PORT_TYPES[1]

    def _get_add_initiators(self, existing, requested):
        all_inits = existing + requested
        add_inits = list(set(all_inits) - set(existing))
        return add_inits

    def _get_remove_initiators(self, existing, requested):
        rem_inits = list(set(existing).intersection(set(requested)))
        return rem_inits

    def _update_chap_details(self, init, current_init, detailed_init):

        chap_parms = [
            'chap_single_username', 'chap_single_password',
            'chap_mutual_username', 'chap_mutual_password']

        if init.startswith('iqn'):
            for param in chap_parms:
                current_init[param] = detailed_init[param]

        return current_init

    def _prepare_add_list_with_type(self, add_list, detailed_initiators):
        add_list_with_type = []
        for init in add_list:
            # when detailed_initiators param is used to add new initiators
            if detailed_initiators:
                for detailed_init in detailed_initiators:
                    if init == detailed_init['port_name']:
                        current_initiator = {}
                        current_initiator['port_name'] = init
                        current_initiator = self._update_chap_details(
                            init=init,
                            current_init=current_initiator,
                            detailed_init=detailed_init)
                        current_initiator['port_type'] = self._get_port_type(initiator=init)
                        add_list_with_type.append(current_initiator)
            # when initiators param is used to add new initiators
            else:
                current_initiator = {}
                current_initiator['port_name'] = init
                current_initiator['port_type'] = self._get_port_type(initiator=init)
                add_list_with_type.append(current_initiator)

        return add_list_with_type

    def add_host_initiators(self, host, modify_dict):
        initiators = self.module.params['initiators']
        detailed_initiators = self.module.params['detailed_initiators']
        add_list = None
        existing_inits = []
        if 'host_initiators' in host:
            current_initiators = host['host_initiators']
            if current_initiators:
                for initiator in current_initiators:
                    existing_inits.append(initiator['port_name'])
        if initiators \
                and (set(initiators).issubset(set(existing_inits))):
            LOG.info('Initiators are already present in host %s',
                     host['name'])

            return modify_dict

        initiator_list = []
        if detailed_initiators is not None:
            initiator_list = [p_name['port_name'] for p_name in
                              detailed_initiators]

        if detailed_initiators and \
                (set(initiator_list).issubset(set(existing_inits))):
            LOG.info('Initiators are already present in host %s',
                     host['name'])
            return modify_dict

        if detailed_initiators:
            initiators = []
            for initiator in detailed_initiators:
                initiators.append(initiator['port_name'])

        add_list = self._get_add_initiators(existing_inits, initiators)
        add_list_with_type = self._prepare_add_list_with_type(
            add_list=add_list, detailed_initiators=detailed_initiators)
        if len(add_list_with_type) > 0:
            modify_dict["add_initiators"] = add_list_with_type
        return modify_dict

    def remove_host_initiators(self, host, modify_dict):
        initiators = self.module.params['initiators']
        detailed_initiators = self.module.params['detailed_initiators']
        remove_list = None
        try:

            existing_inits = []
            current_initiators = host['host_initiators']

            if current_initiators:
                for initiator in current_initiators:
                    existing_inits.append(initiator['port_name'])

            if len(existing_inits) == 0:
                LOG.info('No initiators are present in host %s', host['name'])
                return modify_dict

            if detailed_initiators:
                initiators = []
                for initiator in detailed_initiators:
                    initiators.append(initiator['port_name'])

            remove_list = self._get_remove_initiators(existing_inits,
                                                      initiators)
            if len(remove_list) > 0:
                modify_dict["remove_initiators"] = remove_list
            return modify_dict

        except Exception as e:
            error_msg = (("Removing initiators {0} from host {1} failed"
                          "with error {2}").format(
                remove_list, host['name'], str(e)))
            LOG.error(error_msg)
            self.module.fail_json(msg=error_msg, **utils.failure_codes(e))

    def update_host(self, host, modify_dict):
        try:
            param_list = ['name', 'host_connectivity', 'add_initiators', 'remove_initiators', 'description']
            for param in param_list:
                if param not in modify_dict:
                    modify_dict[param] = None
            if not self.module.check_mode:
                self.conn.provisioning.modify_host(
                    host_id=host['id'],
                    name=modify_dict['name'],
                    host_connectivity=modify_dict['host_connectivity'],
                    add_initiators=modify_dict['add_initiators'],
                    remove_initiators=modify_dict['remove_initiators'],
                    description=modify_dict['description']
                )
            return True
        except Exception as e:
            error_msg = 'Modifying host {0} failed with error {1}'.format(
                host['name'], str(e))
            LOG.error(error_msg)
            self.module.fail_json(msg=error_msg, **utils.failure_codes(e))

    def delete_host(self, host):
        '''
        Delete host from system
        '''
        try:
            if not self.module.check_mode:
                self.conn.provisioning.delete_host(host['id'])
            return True
        except Exception as e:
            error_msg = ('Delete host {0} failed with error {1}'.format(
                host['name'], str(e)))
            LOG.error(error_msg)
            self.module.fail_json(msg=error_msg, **utils.failure_codes(e))

    def validate_detailed_initiators(self, detailed_initiators):
        for initiator in detailed_initiators:
            if (initiator['chap_single_username']
                    or initiator['chap_mutual_username']):
                if initiator['port_type'] == PORT_TYPES[1]:  # FC
                    error_msg = "CHAP authentication is not supported " \
                                "for FC initiator type."
                    LOG.error(error_msg)
                    self.module.fail_json(msg=error_msg)
                if initiator['port_type'] == PORT_TYPES[2]:  # NVMe
                    error_msg = "CHAP authentication is not supported " \
                                "for NVMe initiator type."
                    LOG.error(error_msg)
                    self.module.fail_json(msg=error_msg)
                if "chap_single_username" in initiator and initiator["chap_single_username"] is not None and " " in \
                        initiator["chap_single_username"]:
                    error_msg = "Invalid chap_single_username."
                    LOG.error(error_msg)
                    self.module.fail_json(msg=error_msg)
                if "chap_mutual_username" in initiator and initiator["chap_mutual_username"] is not None and " " in \
                        initiator["chap_mutual_username"]:
                    error_msg = "Invalid chap_mutual_username."
                    LOG.error(error_msg)
                    self.module.fail_json(msg=error_msg)

            pattern = r'^[a-zA-Z0-9+:;,/#_@*%$!()[\]]{12,64}$'
            if (("chap_single_password" in initiator and initiator['chap_single_password'] and
                 not re.match(pattern, initiator['chap_single_password']))
                    or ("chap_mutual_password" in initiator and initiator['chap_mutual_password'] and
                        not re.match(pattern, initiator['chap_mutual_password']))):
                error_msg = "Invalid CHAP password. It must be 12 to 64 characters long and can only contain " \
                            "English letters, numbers, and special characters: + : ; , / # _ @ * % $! ( ) [ ]"
                LOG.error(error_msg)
                self.module.fail_json(msg=error_msg)

    def validate_initiators(self, initiators, detailed_initiators, initiator_state):
        if initiator_state and ((initiators is None or not len(initiators))
                                and (detailed_initiators is None
                                     or not len(detailed_initiators))):
            error_msg = "initiators or detailed_initiators are " \
                        "mandatory along with initiator_state. Please " \
                        "provide a valid value."
            LOG.error(error_msg)
            self.module.fail_json(msg=error_msg)

        if (initiators or detailed_initiators) and initiator_state is None:
            error_msg = "initiator_state is mandatory along with " \
                        "initiators or detailed_initiators. Please " \
                        "provide a valid value."
            LOG.error(error_msg)
            self.module.fail_json(msg=error_msg)

        # validate detailed initiators dict
        if detailed_initiators and initiator_state is not None:
            self.validate_detailed_initiators(detailed_initiators)

    def validate_create(self, initiator_state):
        if self.module.params['new_name']:
            error_msg = "Operation on host failed as new_name is given " \
                        "for a host that doesnt exist."
            LOG.error(error_msg)
            self.module.fail_json(msg=error_msg)

        if initiator_state != "present-in-host":
            error_msg = "Incorrect initiator_state specified for Create" \
                        " host functionality"
            LOG.error(error_msg)
            self.module.fail_json(msg=error_msg)

    def _create_result_dict(self, changed, host_id):
        self.result['changed'] = changed
        if (self.module.params['state'] == 'absent' and not self.module.check_mode) or host_id is None:
            self.result['host_details'] = dict()
        else:
            self.result['host_details'] = self.get_host(host_id)

    def get_diff_after(self, host_params, host_details):
        """Get diff between playbook input and host details
        :param host_params: Dictionary of parameters input from playbook
        :param host_details: Dictionary of host details
        :return: Dictionary of parameters of differences"""

        if host_params["state"] == "absent":
            return {}
        else:
            diff_dict = {}
            if host_details is None:
                diff_dict = {
                    "description": host_params["description"],
                    "host_group_id": "",
                    "host_initiators": [],
                    "id": "",
                    "mapped_hosts": [],
                    "name": host_params["host_name"],
                    "os_type": host_params["os_type"],
                    "host_connectivity": host_params["os_type"],
                    "os_type_l10n": host_params["os_type"]
                }
                if 'initiators' in host_params:
                    diff_dict['host_initiators'] = host_params['initiators']
                elif 'detailed_initiators' in host_params:
                    diff_dict['host_initiators'] = host_params['detailed_initiators']

            else:
                diff_dict = copy.deepcopy(host_details)
                modify_dict = self.is_modify_required(host=diff_dict, host_params=host_params)
                for key in modify_dict.keys():
                    diff_dict[key] = modify_dict[key]
                diff_dict = self.initiator_difference(diff_dict=diff_dict)
            return diff_dict

    def initiator_difference(self, diff_dict):
        refined_init = []
        if diff_dict['host_initiators']:
            for initiator in diff_dict['host_initiators']:
                refined_init.append(initiator['port_name'])
            diff_dict['host_initiators'] = refined_init

            if 'add_initiators' in diff_dict and len(diff_dict['add_initiators']) > 0:
                add_initiators = []
                for initiator in diff_dict['add_initiators']:
                    add_initiators.append(initiator['port_name'])

            if 'add_initiators' in diff_dict:
                diff_dict['host_initiators'] = diff_dict['host_initiators'] + add_initiators
                del diff_dict['add_initiators']
            if 'remove_initiators' in diff_dict:
                diff_dict['host_initiators'] = list(
                    set(diff_dict['host_initiators']) - set(diff_dict['remove_initiators']))
                del diff_dict['remove_initiators']
        return diff_dict

    def check_initiators(self, host, host_params, modify_dict):
        if (host_params['initiator_state'] == 'present-in-host'
                and (host_params['initiators'] or host_params['detailed_initiators'])):
            LOG.info('Adding initiators to host')
            modify_dict = self.add_host_initiators(host=host, modify_dict=modify_dict)

        if (host_params['initiator_state'] == 'absent-in-host'
                and (host_params['initiators'] or host_params['detailed_initiators'])):
            LOG.info('Removing initiators from host')
            modify_dict = self.remove_host_initiators(host, modify_dict)

        return modify_dict

    def is_modify_required(self, host, host_params):
        """ Check whether modification for host is required or not."""
        new_name = host_params["new_name"]
        host_connectivity = host_params["host_connectivity"]
        description = host_params["description"]
        modify_dict = dict()

        if new_name is not None and host['name'] != new_name:
            modify_dict["name"] = new_name
        if description is not None and host['description'] != description:
            modify_dict["description"] = description
        if host_connectivity is not None and \
                host['host_connectivity'] != host_connectivity:
            modify_dict["host_connectivity"] = host_connectivity
        modify_dict = self.check_initiators(
            host=host, host_params=host_params, modify_dict=modify_dict)
        return modify_dict


def get_powerstore_host_parameters():
    """This method provides the parameters required for the ansible host
       module on PowerStore"""
    return dict(
        host_name=dict(required=False, type='str'),
        host_id=dict(required=False, type='str'),
        initiators=dict(required=False, type='list', elements='str'),
        detailed_initiators=dict(
            type='list', required=False, elements='dict',
            options=dict(port_name=dict(type='str', required=True),
                         port_type=dict(type='str', required=False,
                                        choices=PORT_TYPES),
                         chap_single_username=dict(type='str',
                                                   required=False),
                         chap_single_password=dict(type='str',
                                                   required=False,
                                                   no_log=True),
                         chap_mutual_username=dict(type='str',
                                                   required=False),
                         chap_mutual_password=dict(type='str',
                                                   required=False,
                                                   no_log=True))
        ),
        state=dict(choices=['present', 'absent'], default='present'),
        initiator_state=dict(required=False, choices=['absent-in-host',
                                                      'present-in-host'],
                             type='str'),
        new_name=dict(required=False, type='str'),
        os_type=dict(
            required=False, type='str',
            choices=['Windows', 'Linux', 'ESXi', 'AIX', 'HP-UX', 'Solaris']),
        host_connectivity=dict(
            required=False, type='str',
            choices=['Local_Only', 'Metro_Optimize_Both',
                     'Metro_Optimize_Local', 'Metro_Optimize_Remote']),
        description=dict()
    )


class HostExitHandler:
    def handle(self, host_obj, host_id, changed):
        host_obj._create_result_dict(
            changed=changed,
            host_id=host_id)
        # Update the module's final state
        LOG.info('changed %s', changed)
        host_obj.module.exit_json(**host_obj.result)


class HostDeleteHandler:
    def handle(self, host_obj, host_params, host_details, host_id, changed):
        if host_params['state'] == 'absent' and host_details:
            LOG.info('Delete host %s ', host_details['name'])
            changed = host_obj.delete_host(host=host_details) or changed
        HostExitHandler().handle(host_obj, host_id, changed)


class HostModifyHandler:
    def handle(self, host_obj, host_params, host_details, host_id, changed):

        if host_details and host_params['os_type'] and host_params['os_type'] != host_details["os_type"]:
            error_msg = "os_type cannot be modified for an already existing" \
                        " host."
            LOG.error(error_msg)
            host_obj.module.fail_json(msg=error_msg)

        if host_params['state'] == 'present' and host_details:
            modify_dict = host_obj.is_modify_required(
                host=host_details,
                host_params=host_params)
            if modify_dict:
                changed = host_obj.update_host(
                    host=host_details,
                    modify_dict=modify_dict)

        HostDeleteHandler().handle(host_obj, host_params, host_details, host_id, changed)


class HostCreateHandler:
    def handle(self, host_obj, host_params, host_details, host_id, changed):
        if host_params['state'] == 'present' and not host_details and host_params['host_name']:
            host_obj.validate_create(
                initiator_state=host_params['initiator_state'])
            LOG.info('Creating host %s', host_params['host_name'])
            changed = host_obj.create_host(host_name=host_params['host_name'])
            if changed:
                host_id = host_obj.get_host_id_by_name(host_name=host_params['host_name'])
        HostModifyHandler().handle(host_obj, host_params, host_details, host_id, changed)


class HostHandler:
    def handle(self, host_obj, host_params):
        host_id = host_params['host_id']
        if host_params['host_name']:
            host_id = host_obj.get_host_id_by_name(host_name=host_params['host_name'])
        if host_id:
            host_details = host_obj.get_host(host_id=host_id)
        else:
            host_details = None
        changed = False

        host_obj.validate_initiators(
            initiators=host_params['initiators'],
            detailed_initiators=host_params['detailed_initiators'],
            initiator_state=host_params['initiator_state'])

        before_dict = {}
        diff_dict = {}
        diff_dict = host_obj.get_diff_after(host_params=host_params, host_details=host_details)

        if host_details is None:
            before_dict = {}
        else:
            before_dict = copy.deepcopy(host_details)
            if before_dict['host_initiators'] and len(before_dict['host_initiators']) > 0:
                refined_init = []
                for initiator in before_dict['host_initiators']:
                    refined_init.append(initiator['port_name'])
                before_dict['host_initiators'] = refined_init
        if host_obj.module._diff:
            host_obj.result['diff'] = dict(before=before_dict, after=diff_dict)

        HostCreateHandler().handle(host_obj, host_params, host_details, host_id, changed)


def main():
    """ Create PowerStore host object and perform action on it
        based on user input from playbook"""
    obj = PowerStoreHost()
    HostHandler().handle(obj, obj.module.params)


if __name__ == '__main__':
    main()
